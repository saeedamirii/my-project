$(document).ready(function() {
    const em = ["üíê","üåπ","üåª","üèµÔ∏è","üå∫","üå¥","üåà","üçì","üçí","üçé","üçâ","üçä","ü•≠","üçç","üçã","üçè","üçê","ü•ù","üçá","ü••","üçÖ","üå∂Ô∏è","üçÑ","üßÖ","ü•¶","ü•ë","üçî","üçï","üßÅ","üéÇ","üç¨","üç©","üç´","üéà"];
    let currentEmojis = [];
    let firstCard = null, secondCard = null;
    let lockBoard = false;
    let moves = 0;
    let matchesFound = 0;
    let totalPairs = 0;
    let timerInterval;
    let seconds = 0, minutes = 0;
    let currentGameTimeInSeconds = 0;
    let gameMode = "";

    const themeToggleButton = $('#theme-toggle-button');
    const achievementsButton = $('#achievements-button');
    const musicToggleButton = $('#music-toggle-button');
    const bodyElement = $('body');
    const gameBoardElement = $('#game-board');
    const toastNotification = $('#toast-notification');
    const modalContent = $('#modal-content');
    const overlay = $('#overlay');
    const backgroundMusic = document.getElementById('background-music');

    // --- Music Toggle Logic ---
    if (musicToggleButton.length && backgroundMusic) {
        musicToggleButton.on('click', function() {
            if (backgroundMusic.paused) {
                backgroundMusic.play()
                    .then(() => {
                        musicToggleButton.text('‚è∏Ô∏è');
                        musicToggleButton.attr('title', 'ŸÇÿ∑ÿπ ŸÖŸàÿ≤€å⁄©');
                        musicToggleButton.addClass('pulsating-music');
                    })
                    .catch(error => console.error("Error playing music:", error));
            } else {
                backgroundMusic.pause();
                musicToggleButton.text('üéµ');
                musicToggleButton.attr('title', 'ŸæÿÆÿ¥ ŸÖŸàÿ≤€å⁄©');
                musicToggleButton.removeClass('pulsating-music');
            }
        });
    }

    // --- Achievements Logic ---
    let achievements = {
        'first_win':    { id: 'first_win',    name: 'ÿßŸàŸÑ€åŸÜ Ÿæ€åÿ±Ÿàÿ≤€å',      description: 'ÿßŸàŸÑ€åŸÜ ÿ®ÿßÿ≤€å ÿÆŸàÿØ ÿØÿ± Ÿáÿ± ÿ≠ÿßŸÑÿ™€å ÿ±ÿß ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ®Ÿá Ÿæÿß€åÿßŸÜ ÿ®ÿ±ÿ≥ÿßŸÜ€åÿØ.', icon: 'ü•á', unlocked: false, check: () => totalGamesWon === 1 },
        'explorer_4x4': { id: 'explorer_4x4', name: '⁄©ÿßÿ¥ŸÅ ÿ®ÿßÿ™ÿ¨ÿ±ÿ®Ÿá',     description: 'ÿ≠ÿßŸÑÿ™ ÿ®ÿßÿ≤€å 4x4 ÿ±ÿß ⁄©ÿßŸÖŸÑ ⁄©ŸÜ€åÿØ.',                              icon: 'üó∫Ô∏è', unlocked: false, check: (mode) => mode === '4x4' },
        'master_6x6':   { id: 'master_6x6',   name: 'ÿßÿ≥ÿ™ÿßÿØ ÿ®ÿ≤ÿ±⁄Ø ÿ≠ÿßŸÅÿ∏Ÿá',  description: 'ÿ≠ÿßŸÑÿ™ ÿ®ÿßÿ≤€å 6x6 ÿ±ÿß ⁄©ÿßŸÖŸÑ ⁄©ŸÜ€åÿØ.',                              icon: 'üèÜ', unlocked: false, check: (mode) => mode === '6x6' },
        'combo_3':      { id: 'combo_3',      name: 'ÿ∂ÿ±ÿ®ÿßÿ™ ŸÖÿ™ŸàÿßŸÑ€å',      description: '€≥ ÿ¨ŸÅÿ™ ⁄©ÿßÿ±ÿ™ ÿ±ÿß Ÿæÿ¥ÿ™ ÿ≥ÿ± ŸáŸÖ Ÿà ÿ®ÿØŸàŸÜ ÿßÿ¥ÿ™ÿ®ÿßŸá Ÿæ€åÿØÿß ⁄©ŸÜ€åÿØ.',        icon: '‚ö°', unlocked: false, check: () => consecutiveMatches >= 3 },
        'loyal_player': { id: 'loyal_player', name: 'ÿ®ÿßÿ≤€å⁄©ŸÜ ŸàŸÅÿßÿØÿßÿ±',      description: 'ÿØÿ± ŸÖÿ¨ŸÖŸàÿπ €µ ÿ®ÿßÿ≤€å ⁄©ÿßŸÖŸÑ ÿßŸÜÿ¨ÿßŸÖ ÿØŸá€åÿØ (ÿ®ÿ±ŸÜÿØŸá ÿ¥Ÿà€åÿØ).',             icon: 'üí™', unlocked: false, check: () => totalGamesWon >= 5 },
        'collector_50': { id: 'collector_50', name: '⁄©ŸÑ⁄©ÿ≥€åŸàŸÜÿ± ⁄©ÿßÿ±ÿ™',     description: 'ÿØÿ± ÿ™ŸÖÿßŸÖ ÿ®ÿßÿ≤€å‚ÄåŸáÿß€å ÿÆŸàÿØ ŸÖÿ¨ŸÖŸàÿπÿßŸã €µ€∞ ÿ¨ŸÅÿ™ ⁄©ÿßÿ±ÿ™ ÿµÿ≠€åÿ≠ Ÿæ€åÿØÿß ⁄©ŸÜ€åÿØ.', icon: 'üÉè', unlocked: false, check: () => totalPairsEverFound >= 50 },
        'flawless_3x4': { id: 'flawless_3x4', name: 'ÿ®ÿßÿ≤€å ÿ®€å‚ÄåŸÜŸÇÿµ (⁄©Ÿà⁄Ü⁄©)', description: 'ÿ≠ÿßŸÑÿ™ 3x4 ÿ±ÿß ÿ®ÿß ÿ≠ÿØÿß⁄©ÿ´ÿ± €∂ ÿ≠ÿ±⁄©ÿ™ (ÿ®ÿØŸàŸÜ ÿÆÿ∑ÿß) ⁄©ÿßŸÖŸÑ ⁄©ŸÜ€åÿØ.', icon: 'üíé', unlocked: false, check: (mode, mvs) => mode === '3x4' && mvs <= 6 },
        'golden_4x4':   { id: 'golden_4x4',   name: 'ÿ≠ÿ±⁄©ÿßÿ™ ÿ∑ŸÑÿß€å€å (ŸÖÿ™Ÿàÿ≥ÿ∑)',description: 'ÿ≠ÿßŸÑÿ™ 4x4 ÿ±ÿß ÿ®ÿß ÿ≠ÿØÿß⁄©ÿ´ÿ± €π ÿ≠ÿ±⁄©ÿ™ (ÿ™ÿß €± ÿÆÿ∑ÿß) ⁄©ÿßŸÖŸÑ ⁄©ŸÜ€åÿØ.', icon: 'üåü', unlocked: false, check: (mode, mvs) => mode === '4x4' && mvs <= 9 },
        'strategist_5x6':{ id: 'strategist_5x6',name: 'ÿßÿ≥ÿ™ÿ±ÿßÿ™⁄ò€åÿ≥ÿ™ ÿ®ÿ±ÿ™ÿ± (ÿ®ÿ≤ÿ±⁄Ø)', description: 'ÿ≠ÿßŸÑÿ™ 5x6 ÿ±ÿß ÿ®ÿß ÿ≠ÿØÿß⁄©ÿ´ÿ± €±€∏ ÿ≠ÿ±⁄©ÿ™ (ÿ™ÿß €≥ ÿÆÿ∑ÿß) ⁄©ÿßŸÖŸÑ ⁄©ŸÜ€åÿØ.', icon: 'üß≠', unlocked: false, check: (mode, mvs) => mode === '5x6' && mvs <= 18 },
        'precision_6x6':{ id: 'precision_6x6', name: '⁄ÜÿßŸÑÿ¥ ÿØŸÇÿ™ (ÿ≠ÿ±ŸÅŸá‚Äåÿß€å)',description: 'ÿ≠ÿßŸÑÿ™ 6x6 ÿ±ÿß ÿ®ÿß ÿ≠ÿØÿß⁄©ÿ´ÿ± €≤€≤ ÿ≠ÿ±⁄©ÿ™ (ÿ™ÿß €¥ ÿÆÿ∑ÿß) ⁄©ÿßŸÖŸÑ ⁄©ŸÜ€åÿØ.', icon: 'üéØ', unlocked: false, check: (mode, mvs) => mode === '6x6' && mvs <= 22 }
    };

    let consecutiveMatches = 0;
    let totalGamesWon = 0;
    let totalPairsEverFound = 0;

    function loadStatsAndAchievements() {
        const savedAchievements = JSON.parse(localStorage.getItem('memoryGameAchievementsStatus'));
        if (savedAchievements) {
            for (const id in achievements) {
                if (achievements.hasOwnProperty(id) && savedAchievements[id] !== undefined) {
                    achievements[id].unlocked = savedAchievements[id];
                }
            }
        }
        totalGamesWon = parseInt(localStorage.getItem('memoryGameTotalGamesWon')) || 0;
        totalPairsEverFound = parseInt(localStorage.getItem('memoryGameTotalPairsEverFound')) || 0;
    }

    function saveStatsAndAchievements() {
        let statuses = {};
        for (const id in achievements) {
            if (achievements.hasOwnProperty(id)) {
                statuses[id] = achievements[id].unlocked;
            }
        }
        localStorage.setItem('memoryGameAchievementsStatus', JSON.stringify(statuses));
        localStorage.setItem('memoryGameTotalGamesWon', totalGamesWon);
        localStorage.setItem('memoryGameTotalPairsEverFound', totalPairsEverFound);
    }
    
    function showToast(message) {
        toastNotification.text(message);
        toastNotification.addClass('show');
        setTimeout(() => {
            toastNotification.removeClass('show');
        }, 3500);
    }

    function unlockAchievement(id) {
        if (achievements[id] && !achievements[id].unlocked) {
            achievements[id].unlocked = true;
            showToast(`ŸÖÿØÿßŸÑ "${achievements[id].name}" ⁄©ÿ≥ÿ® ÿ¥ÿØ! ${achievements[id].icon}`);
            saveStatsAndAchievements(); 
            if (overlay.is(':visible') && $('#achievements-list-container').length) {
                 displayAchievements();
            }
        }
    }

    function checkAllAchievements(checkTime, param1, param2) { // param1 is mode, param2 is moves for 'gameEnd'
        for (const id in achievements) {
            if (achievements.hasOwnProperty(id) && !achievements[id].unlocked) {
                let conditionMet = false;
                try { 
                    if (checkTime === 'gameEnd') { 
                        conditionMet = achievements[id].check(param1, param2); 
                    } else if (checkTime === 'pairFound') { 
                        conditionMet = achievements[id].check(); 
                    }
                } catch (e) {
                    console.error("Error checking achievement:", id, e, "Check function:", achievements[id].check);
                }
                if (conditionMet) {
                    unlockAchievement(id);
                }
            }
        }
    }
    
    function displayAchievements() {
        let listHTML = '<div id="achievements-list-container"><ul id="achievements-list">';
        for (const id in achievements) {
            if (achievements.hasOwnProperty(id)) {
                const ach = achievements[id];
                listHTML += `
                    <li class="achievement-item ${ach.unlocked ? 'unlocked' : 'locked'}">
                        <span class="icon">${ach.icon}</span>
                        <div class="details">
                            <h4>${ach.name}</h4>
                            <p>${ach.description}</p>
                        </div>
                    </li>`;
            }
        }
        listHTML += '</ul></div>';
        
        modalContent.html(`<h2>ŸÖÿØÿßŸÑ‚ÄåŸáÿß Ÿà ÿØÿ≥ÿ™ÿßŸàÿ±ÿØŸáÿß</h2>` + listHTML + '<button id="close-modal-button" class="general-modal-button" style="margin-top:20px; flex-shrink: 0;">ÿ®ÿ≥ÿ™ŸÜ</button>');
        overlay.fadeIn(300);
    }
    
    achievementsButton.on('click', displayAchievements);
    modalContent.on('click', '#close-modal-button', function() { 
        overlay.fadeOut(300);
    });

    // --- High Score Logic ---
    function getHighScores() {
        const scores = localStorage.getItem('memoryGameHighScores');
        return scores ? JSON.parse(scores) : {};
    }
    function saveHighScores(scores) {
        localStorage.setItem('memoryGameHighScores', JSON.stringify(scores));
    }
    function updateHighScore(mode, currentMoves, currentTimeInSeconds) {
        const highScores = getHighScores();
        const currentBest = highScores[mode];
        let newRecordString = "";
        if (!currentBest || currentMoves < currentBest.moves || (currentMoves === currentBest.moves && currentTimeInSeconds < currentBest.timeInSeconds)) {
            highScores[mode] = { moves: currentMoves, timeInSeconds: currentTimeInSeconds };
            saveHighScores(highScores);
            newRecordString = "üéâ ÿ±⁄©Ÿàÿ±ÿØ ÿ¨ÿØ€åÿØ! üéâ";
        }
        return newRecordString;
    }
    function formatTime(totalSeconds) {
        const m = Math.floor(totalSeconds / 60);
        const s = totalSeconds % 60;
        const displayM = String(m).padStart(2, '€∞').replace(/[0-9]/g, d => '€∞€±€≤€≥€¥€µ€∂€∑€∏€π'[d]);
        const displayS = String(s).padStart(2, '€∞').replace(/[0-9]/g, d => '€∞€±€≤€≥€¥€µ€∂€∑€∏€π'[d]);
        return `${displayM}:${displayS}`;
    }

    // --- Theme Toggle Logic ---
    function applyTheme(theme) {
        if (theme === 'day') {
            bodyElement.addClass('day-mode');
            themeToggleButton.text('‚òÄÔ∏è');
            themeToggleButton.attr('title', 'ÿ™ÿ∫€å€åÿ± ÿ®Ÿá ÿ™ŸÖ ÿ¥ÿ®');
        } else {
            bodyElement.removeClass('day-mode');
            themeToggleButton.text('üåô');
            themeToggleButton.attr('title', 'ÿ™ÿ∫€å€åÿ± ÿ®Ÿá ÿ™ŸÖ ÿ±Ÿàÿ≤');
        }
    }
    const initialTheme = localStorage.getItem('memoryGameTheme') || 'night'; 
    applyTheme(initialTheme); 

    themeToggleButton.on('click', function() {
        let currentTheme = bodyElement.hasClass('day-mode') ? 'day' : 'night';
        const newTheme = (currentTheme === 'day' ? 'night' : 'day');
        applyTheme(newTheme);
        localStorage.setItem('memoryGameTheme', newTheme);
    });

    // --- Game Logic ---
    function showInitialModal() {
        const modalHTML = `
            <div id="inst">
                <h3>ÿ±ÿßŸáŸÜŸÖÿß€å ÿ®ÿßÿ≤€å:</h3>
                <ul>
                    <li>ÿ®ÿß ÿ®ÿ±⁄Øÿ±ÿØÿßŸÜÿØŸÜ ÿ®ŸÑŸà⁄©‚ÄåŸáÿßÿå ÿ¨ŸÅÿ™‚ÄåŸáÿß€å ŸÖÿ¥ÿßÿ®Ÿá ÿ±ÿß Ÿæ€åÿØÿß ⁄©ŸÜ€åÿØ.</li>
                    <li>ÿ®ÿ±ÿß€å ÿ®ÿ±⁄Øÿ±ÿØÿßŸÜÿØŸÜ €å⁄© ÿ®ŸÑŸà⁄©ÿå ÿ±Ÿà€å ÿ¢ŸÜ ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.</li>
                    <li>ÿßŸÜÿ™ÿÆÿßÿ® ÿØÿ±ÿ≥ÿ™ €± ÿ≠ÿ±⁄©ÿ™ Ÿà ÿßŸÜÿ™ÿÆÿßÿ® ÿßÿ¥ÿ™ÿ®ÿßŸá €≤ ÿ≠ÿ±⁄©ÿ™ ÿ®ÿ±ÿß€å ÿ¥ŸÖÿß ÿ´ÿ®ÿ™ ŸÖ€å‚Äå⁄©ŸÜÿØ.</li>
                </ul>
                <p style="font-size:1.1em; margin-top: 20px; margin-bottom: 15px;">ÿ®ÿ±ÿß€å ÿ¥ÿ±Ÿàÿπÿå €å⁄©€å ÿßÿ≤ ÿ≠ÿßŸÑÿ™‚ÄåŸáÿß€å ÿ≤€åÿ± ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:</p>
            </div>
            <div id="mode-selection">
                <button data-mode="3x4">3 x 4</button> <button data-mode="4x4">4 x 4</button>
                <button data-mode="4x5">4 x 5</button> <button data-mode="5x6">5 x 6</button>
                <button data-mode="6x6">6 x 6</button>
            </div>`;
        modalContent.html(modalHTML); 
        overlay.fadeIn(300);
    }
    modalContent.on('click', '#mode-selection button', function() { 
        const modeParts = $(this).data('mode').split('x');
        const r = parseInt(modeParts[0]);
        const l = parseInt(modeParts[1]);
        gameMode = $(this).data('mode');
        startGame(r, l);
    });

    function resetGameStats() {
        moves = 0; matchesFound = 0; seconds = 0; minutes = 0; currentGameTimeInSeconds = 0;
        consecutiveMatches = 0; 
        $('#moves-display').text("ÿ≠ÿ±⁄©ÿ™‚ÄåŸáÿß: €∞");
        $('#time-display').text("ÿ≤ŸÖÿßŸÜ: €∞€∞:€∞€∞");
        if (timerInterval) clearInterval(timerInterval);
        lockBoard = false; firstCard = null; secondCard = null;
    }

    function startTimer() {
        timerInterval = setInterval(function() {
            seconds++; currentGameTimeInSeconds++;
            if (seconds === 60) { minutes++; seconds = 0; }
            $('#time-display').text(`ÿ≤ŸÖÿßŸÜ: ${formatTime(currentGameTimeInSeconds)}`);
        }, 1000);
    }

    function createBoard(rows, cols) {
        gameBoardElement.html(''); 
        gameBoardElement.attr('data-cols', cols); 
        let itemIndex = 0;
        let cardElements = []; 

        for (let i = 0; i < rows; i++) {
            const tr = $('<tr></tr>');
            for (let j = 0; j < cols; j++) {
                const cardEmoji = currentEmojis[itemIndex];
                const cardInner = $(`<div class="card-inner" data-emoji="${cardEmoji}"><div class="card-front"></div><div class="card-back"><p>${cardEmoji}</p></div></div>`);
                const td = $('<td></td>').append(cardInner);
                tr.append(td);
                cardElements.push(cardInner); 
                itemIndex++;
            }
            gameBoardElement.append(tr);
        }

        cardElements.forEach((card, index) => {
            setTimeout(() => {
                card.addClass('card-visible'); 
            }, index * 60); 
        });

        $('.card-inner').on('click', handleCardClick); 
    }
    
    function startGame(r, l) {
        resetGameStats();
        totalPairs = (r * l) / 2;
        let availableEmojis = [...em]; 
        for (let i = availableEmojis.length - 1; i > 0; i--) { 
            const j = Math.floor(Math.random() * (i + 1));
            [availableEmojis[i], availableEmojis[j]] = [availableEmojis[j], availableEmojis[i]];
        }
        const selectedBaseEmojis = availableEmojis.slice(0, totalPairs);
        if (selectedBaseEmojis.length < totalPairs) { 
            console.warn("Emoji ⁄©ŸÖ ÿßÿ≥ÿ™ÿå ÿ®ÿ±ÿÆ€å ÿ™⁄©ÿ±ÿßÿ± ŸÖ€å‚Äåÿ¥ŸàŸÜÿØ.");
            let tempEmojis = [];
            for(let i = 0; i < totalPairs; i++) tempEmojis.push(availableEmojis[i % availableEmojis.length]);
            currentEmojis = [...tempEmojis, ...tempEmojis];
        } else {
            currentEmojis = [...selectedBaseEmojis, ...selectedBaseEmojis];
        }
        for (let i = currentEmojis.length - 1; i > 0; i--) { 
            const j = Math.floor(Math.random() * (i + 1));
            [currentEmojis[i], currentEmojis[j]] = [currentEmojis[j], currentEmojis[i]];
        }
        createBoard(r, l); 
        startTimer();
        overlay.fadeOut(300);
    }
    
    function incrementMoves(count = 1) { 
        moves += count;
        $('#moves-display').text(`ÿ≠ÿ±⁄©ÿ™‚ÄåŸáÿß: ${String(moves).replace(/[0-9]/g, d => '€∞€±€≤€≥€¥€µ€∂€∑€∏€π'[d])}`);
    }

    function handleCardClick() {
        const clickedCard = $(this); // Store this to avoid issues with 'this' in setTimeout
        if (lockBoard || clickedCard.hasClass('is-flipped') || clickedCard.hasClass('is-matched')) return;
        
        // Add 'is-flipped' for visual flip, actual transform in CSS
        // The transform style is on .card-inner itself, so the .is-flipped should be there too.
        // My previous CSS for .card-inner.is-flipped was just transform: rotateY(180deg)
        // The base .card-inner has the dealing animation (opacity, scale, translate)
        // Need to ensure .is-flipped correctly overrides or combines with .card-visible
        // Best to put the flip transform directly on .is-flipped and remove the transition from base .card-inner,
        // or ensure the flip animation uses its own specific transition.
        // Let's ensure the flip has its own transition by moving the general 'transition' off the base .card-inner
        // and onto .card-inner.is-flipped for the 'transform' property,
        // and keep the opacity/transform transition on the base for the dealing.
        // The current setup adds 'is-flipped', and CSS has a transition for transform on .card-inner.
        // Let's simplify: the current CSS on .card-inner for transition includes transform 0.7s.
        // .card-inner.is-flipped then changes the transform. This should be okay.

        clickedCard.addClass('is-flipped');

        if (!firstCard) {
            firstCard = clickedCard;
            return;
        }
        secondCard = clickedCard;
        lockBoard = true;
        checkForMatch();
    }

    function checkForMatch() {
        const emojisMatch = firstCard.data('emoji') === secondCard.data('emoji');
        if (emojisMatch) {
            incrementMoves(1); 
            disableCards();
        } else {
            incrementMoves(2); 
            unflipCards();
        }
    }

    function disableCards() {
        firstCard.addClass('is-matched');
        secondCard.addClass('is-matched');
        matchesFound++;
        consecutiveMatches++;
        totalPairsEverFound++;
        saveStatsAndAchievements(); 
        checkAllAchievements('pairFound');
        resetTurn();
        if (matchesFound === totalPairs) {
            endGame();
        }
    }

    function unflipCards() {
        consecutiveMatches = 0; 
        setTimeout(() => {
            if (firstCard) firstCard.removeClass('is-flipped');
            if (secondCard) secondCard.removeClass('is-flipped');
            resetTurn();
        }, 1200);
    }

    function resetTurn() {
        [firstCard, secondCard] = [null, null];
        lockBoard = false;
    }

    function endGame() {
        clearInterval(timerInterval);
        totalGamesWon++; 
        saveStatsAndAchievements(); 

        const timeTakenDisplayString = formatTime(currentGameTimeInSeconds);
        const newRecordMessage = updateHighScore(gameMode, moves, currentGameTimeInSeconds);
        const highScores = getHighScores();
        const bestScoreForMode = highScores[gameMode];
        let bestScoreDisplayString = "ŸáŸÜŸàÿ≤ ÿ±⁄©Ÿàÿ±ÿØ€å ÿ®ÿ±ÿß€å ÿß€åŸÜ ÿ≠ÿßŸÑÿ™ ÿ´ÿ®ÿ™ ŸÜÿ¥ÿØŸá.";
        if (bestScoreForMode) {
            bestScoreDisplayString = `ÿ®Ÿáÿ™ÿ±€åŸÜ ÿ±⁄©Ÿàÿ±ÿØ: ${String(bestScoreForMode.moves).replace(/[0-9]/g, d => '€∞€±€≤€≥€¥€µ€∂€∑€∏€π'[d])} ÿ≠ÿ±⁄©ÿ™ ÿØÿ± ${formatTime(bestScoreForMode.timeInSeconds)}`;
        }
        const movesDisplayString = String(moves).replace(/[0-9]/g, d => '€∞€±€≤€≥€¥€µ€∂€∑€∏€π'[d]);

        checkAllAchievements('gameEnd', gameMode, moves); 

        const modalHTML = `
            <h2 class="${newRecordMessage ? 'record-message' : ''}">${newRecordMessage ? newRecordMessage : "ÿ™ÿ®ÿ±€å⁄©! ÿ¥ŸÖÿß ÿ®ÿ±ŸÜÿØŸá ÿ¥ÿØ€åÿØ!"}</h2>
            <p>ÿ¥ŸÖÿß ÿ≠ÿßŸÑÿ™ ${gameMode.replace('x', ' ÿØÿ± ')} ÿ±ÿß ÿ®ÿß ${movesDisplayString} ÿ≠ÿ±⁄©ÿ™ ÿ®Ÿá Ÿæÿß€åÿßŸÜ ÿ±ÿ≥ÿßŸÜÿØ€åÿØ.</p>
            <p>ÿ≤ŸÖÿßŸÜ ÿ¥ŸÖÿß: ${timeTakenDisplayString}</p>
            <p class="best-score-text">${bestScoreDisplayString}</p>
            <p style="font-size:1.1em; margin-top: 25px; margin-bottom: 15px;">ÿØŸàÿ®ÿßÿ±Ÿá ÿ®ÿßÿ≤€å ŸÖ€å‚Äå⁄©ŸÜ€åÿØÿü</p>
            <div id="mode-selection">
                <button data-mode="3x4">3 x 4</button> <button data-mode="4x4">4 x 4</button>
                <button data-mode="4x5">4 x 5</button> <button data-mode="5x6">5 x 6</button>
                <button data-mode="6x6">6 x 6</button>
            </div>`;
        setTimeout(() => {
            modalContent.html(modalHTML);
            overlay.fadeIn(500);
        }, 700);
    }

    // --- Initial Load ---
    loadStatsAndAchievements();
    applyTheme(initialTheme); 
    showInitialModal();
});
        
